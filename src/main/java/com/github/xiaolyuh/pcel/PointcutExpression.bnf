// 第七步:定义bnf语法
// 第八步:右键生成parse code
// 第九步:右键生成flex文件
{
  parserClass="com.github.xiaolyuh.pcel.parser.PointcutExpressionParser"
  parserUtilClass="com.github.xiaolyuh.pcel.parser.PointcutExpressionParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="PointcutExpression"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.xiaolyuh.pcel.psi"
  psiImplPackage="com.github.xiaolyuh.pcel.psi.impl"

  elementTypeHolderClass="com.github.xiaolyuh.pcel.psi.PointcutExpressionTypes"
  elementTypeClass="com.github.xiaolyuh.pcel.psi.PointcutExpressionElementType"
  tokenTypeClass="com.github.xiaolyuh.pcel.psi.PointcutExpressionTokenType"
  psiImplUtilClass="com.github.xiaolyuh.pcel.psi.impl.PointcutExpressionPsiImplUtil"

  tokens=[
    ANNOTATION='@annotation'
    ANNO_TARGET='@target'
    EXECUTION='execution'
    BEAN='bean'
    EXPR="regexp:\([\w*!+.\s()]+\)"
    METHOD_REFERENCE="regexp:\p{Alpha}\w*\(\)"
    OR_OPERATOR="regexp:\s*\|\|\s*"
    AND_OPERATOR="regexp:\s*&&\s*"
  ]
}

pointcutExpressionFile ::= item_*
private item_ ::= aop_pointcut
aop_pointcut ::= aop_content aop_parallel_pointcut? {
    pin = 1
}
aop_content ::= aop_real | aop_method_reference
aop_real ::= aop_kind aop_expr
aop_kind ::= ANNOTATION | ANNO_TARGET | EXECUTION | BEAN
aop_expr ::= EXPR
aop_method_reference ::= METHOD_REFERENCE
aop_parallel_pointcut ::= (OR_OPERATOR | AND_OPERATOR) aop_pointcut

